#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
void main()
{
    __int64 a,b;
    while(scanf("%X%X",&a,&b)!=EOF
)    {
        a+=b;
        printf("%X\n",a);
    }
    return 0;
}

/*
hdu2057
都是基础知识！

http://acm.hdu.edu.cn/showproblem.php?pid=2057

看了一位dn的解释，借鉴了：

http://hi.baidu.com/gminking/blog/item/691ee158d213754dfbf2c016.html/cmtid/881e0f308ee322345bb5f5a4

题目求的是十六进制的加法。刚开始想的是把十六进制转化为十进制，进行加法运算后，再
转化为十六进制。后来发现自己忘了C中存在十六进制的输入输出（%X，%x）。所以这题可
以直接用十六进制输入，然后进行十六进制的运算（其实不管是什么进制，在计算机中都是
以二进制来计算的，只是按输入输出的格式不同，而强制转化为其它的进制），就像十进制的
加法一样。这里要注意的是输入小于15位，结果超过了二进制中的32位而小于64位。所以
这里用__int64的类型。输入输入出格式就是（%I64x,%I64X）。由于%I64X，不能输出
负数，所以负数的输出要做处理。
在这里 你要明白的是 计算机存入的数据是二进制 0 1  所以

scanf("%d",&a);就是你输入的一个十进制 比如 你输入10（这边是十进制数） 他也代表

10（十六进制） 计算机存储是 10000

scanf("%x",&a);就是你输入的一个十六进制 比如 你输入10（是这边是十六进制数） 

他也代表8（十进制） 计算机存储是 1000

而在计算b=a/15-273 的时候 计算机是用它们各自表示的二进制来计算的 因此事实上得到

的b存在计算机里是以二进制存在的 只是当你输出时候利用强制转换输出才变成我们想要的

十进制或者十六进制 比如： 在b输出时候用十六进制输出 也就是printf("%x",b);
*/