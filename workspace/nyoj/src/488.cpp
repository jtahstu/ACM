/***********************************************************************
输入正整数n,把整数1,2,3……,n组成一个环,使得相邻两个整数之和均为素数,输出时从整数1开始逆时针排序.同一个环应恰好输出一次.n<==16
样例输入：
6
样例输出:
1 4 3 2 5 66
1 6 5 2 3 4

分析:
1、每个环都从1开始，先将数组a[0]赋值1.
2、每选定前一个素数，后一个位置就少一个可选择项，由此可用一个数组bUsed[]来标记状态.
3、前一个后一个选定值总和前一个选定值关联，由此可用回溯法(深度优先遍历的方式遍历解答树)。
************************************************************************/
//
//#include <iostream>
//#include <math.h>
//using namespace std;
//int n=0;//输入n<=16
//int a[20];
//bool bUsed[20];//对应数组a[20],判断对应节点在当前求得素数环中(解答树)是否有它
//
///*判断是素数*/
//bool isp(int n){
//	if(n<3)
//		return false ;
//	int len=(int)sqrt(n+0.0);
//	for (int i=2;i<=len;i++){
//		if(n%i==0)
//			return false ;
//	}
//	return true;
//}
//
///*递归输出所有素数环*/
//void AA(int cur){
//	//在最后一层执行,输出当前求得解答串
//	if(cur==n&&isp(a[0]+a[n-1])){
//		for (int i=0;i<n;i++)
//			cout<<a[i]<<' ';
//		cout<<endl;
//		return ;
//	}
//	//前n-1层执行,递归选定每一层的整数,使其与前一层的整数之和为素数
//	else for (int i=2;i<= n;i++){
//		if(!bUsed[i]&&isp(i+a[cur-1])){	//当前值i没被使用,且与前一个选定值之和为素数
//			a[cur]=i;//选i为当前项值
//			bUsed[i]=true;//状态从没被使用改为被使用
//			AA(cur+1);//进入下一层,若cur+1<n则求下一个有效值,否则执行输出语句
//			//递归后面的语句在从n-1层到第1层回调时执行
//			bUsed[i]=false;//状态还原,使重新求下一个有效串时不被干扰
//		}
//	}
//}
//
//int main488(){
//	for (int i=0;i<20;i++)
//		a[i]=i+1;//初始化一个数组1,2,3,4...
//	memset(bUsed,0,sizeof(bUsed));//全部初始化为false表示均没被使用
//	while (cin>>n,n){
//		AA(1);//回溯法遍历解答树,输出所有素数环
//	}
//}
