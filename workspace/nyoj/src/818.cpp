/**
 * Project Name: nyoj
 * File Name: 818.cpp
 * Created on: 2015年7月17日 上午12:49:48
 * Author: jtahstu
 * QQ: 1373758426 E-mail:1373758426@qq.com
 * Copyright (c) 2015, jtahstu , All Rights Reserved.
 */
//#include<iostream>
//using namespace std;
//int main818() {
//	int n, count = 0;
//	cin >> n;
//	while (n--) {
//		int a, b;
//		cin >> a >> b;
//		cout << "# " << ++count << ":" << endl;
//		if ((a * b) & 1) //如果是个奇数，则有一条斜线，即√2代替1，多了个0.414....
//			cout << a * b << ".41" << endl;
//		else
//			//如果是个偶数，则走一圈
//			cout << a * b << ".00" << endl;
//	}
//	return 0;
//}
//送货
//时间限制：1000 ms  |  内存限制：65535 KB
//难度：2
//描述
//在China，假设每个城市都位于矩形网格的一个点上。通向每个城市的道路只有东，西，南，北，东南，东北，西南，西北八个方向。
//在每个方向上只有一个相邻的城市，其中规定东西，南北方向上的长度为1。问一个售货员经过所有的城市并回到出发点的最短路径是多少？
//
//输入
//第一行N(0<N<500)为测试数据组数
//对每个测试例，在一行里有两个整数m，n，分别是矩形的相邻两条边的城市个数（1<m,n<=10000）
//输出
//对每个测试例，第一行输出：“# i：”，i是从1开始的测试例编号，第二行输出售货员的最短路径（精确到两位小数）
//样例输入
//2
//2 2
//2 3
//样例输出
//# 1:
//4.00
//# 2:
//6.00
//提示
//对与样例1：矩形城市为长和宽都为1的矩形，每条边有两个城市，故四个顶点（四个城市），走一圈即可。
